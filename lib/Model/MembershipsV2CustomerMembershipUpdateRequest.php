<?php
/**
 * MembershipsV2CustomerMembershipUpdateRequest
 *
 * PHP version 7.4
 *
 * @category Class
 * @package  CompWright\ServiceTitan
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Memberships
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.10.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace CompWright\ServiceTitan\Model;

use \ArrayAccess;
use \CompWright\ServiceTitan\ObjectSerializer;

/**
 * MembershipsV2CustomerMembershipUpdateRequest Class Doc Comment
 *
 * @category Class
 * @package  CompWright\ServiceTitan
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<string, mixed>
 */
class MembershipsV2CustomerMembershipUpdateRequest implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'Memberships.V2.CustomerMembershipUpdateRequest';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'business_unit_id' => 'int',
        'next_scheduled_bill_date' => '\DateTime',
        'status' => '\CompWright\ServiceTitan\Model\MembershipsV2CustomerMembershipUpdateRequestStatus',
        'memo' => 'string',
        'from' => '\DateTime',
        'to' => '\DateTime',
        'sold_by_id' => 'int',
        'billing_template_id' => 'int',
        'location_id' => 'int',
        'recurring_service_action' => '\CompWright\ServiceTitan\Model\MembershipsV2CustomerMembershipUpdateRequestRecurringServiceAction',
        'recurring_location_id' => 'int',
        'payment_method_id' => 'int',
        'payment_type_id' => 'int',
        'renewal_membership_task_id' => 'int',
        'initial_deferred_revenue' => 'float',
        'cancellation_balance_invoice_id' => 'int',
        'cancellation_invoice_id' => 'int'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'business_unit_id' => 'int64',
        'next_scheduled_bill_date' => 'date-time',
        'status' => null,
        'memo' => null,
        'from' => 'date-time',
        'to' => 'date-time',
        'sold_by_id' => 'int64',
        'billing_template_id' => 'int64',
        'location_id' => 'int64',
        'recurring_service_action' => null,
        'recurring_location_id' => 'int64',
        'payment_method_id' => 'int64',
        'payment_type_id' => 'int64',
        'renewal_membership_task_id' => 'int64',
        'initial_deferred_revenue' => 'decimal',
        'cancellation_balance_invoice_id' => 'int64',
        'cancellation_invoice_id' => 'int64'
    ];

    /**
      * Array of nullable properties. Used for (de)serialization
      *
      * @var boolean[]
      */
    protected static array $openAPINullables = [
        'business_unit_id' => false,
        'next_scheduled_bill_date' => true,
        'status' => false,
        'memo' => false,
        'from' => false,
        'to' => true,
        'sold_by_id' => true,
        'billing_template_id' => true,
        'location_id' => true,
        'recurring_service_action' => false,
        'recurring_location_id' => true,
        'payment_method_id' => true,
        'payment_type_id' => true,
        'renewal_membership_task_id' => false,
        'initial_deferred_revenue' => false,
        'cancellation_balance_invoice_id' => true,
        'cancellation_invoice_id' => true
    ];

    /**
      * If a nullable field gets set to null, insert it here
      *
      * @var boolean[]
      */
    protected array $openAPINullablesSetToNull = [];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of nullable properties
     *
     * @return array
     */
    protected static function openAPINullables(): array
    {
        return self::$openAPINullables;
    }

    /**
     * Array of nullable field names deliberately set to null
     *
     * @return boolean[]
     */
    private function getOpenAPINullablesSetToNull(): array
    {
        return $this->openAPINullablesSetToNull;
    }

    /**
     * Setter - Array of nullable field names deliberately set to null
     *
     * @param boolean[] $openAPINullablesSetToNull
     */
    private function setOpenAPINullablesSetToNull(array $openAPINullablesSetToNull): void
    {
        $this->openAPINullablesSetToNull = $openAPINullablesSetToNull;
    }

    /**
     * Checks if a property is nullable
     *
     * @param string $property
     * @return bool
     */
    public static function isNullable(string $property): bool
    {
        return self::openAPINullables()[$property] ?? false;
    }

    /**
     * Checks if a nullable property is set to null.
     *
     * @param string $property
     * @return bool
     */
    public function isNullableSetToNull(string $property): bool
    {
        return in_array($property, $this->getOpenAPINullablesSetToNull(), true);
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'business_unit_id' => 'businessUnitId',
        'next_scheduled_bill_date' => 'nextScheduledBillDate',
        'status' => 'status',
        'memo' => 'memo',
        'from' => 'from',
        'to' => 'to',
        'sold_by_id' => 'soldById',
        'billing_template_id' => 'billingTemplateId',
        'location_id' => 'locationId',
        'recurring_service_action' => 'recurringServiceAction',
        'recurring_location_id' => 'recurringLocationId',
        'payment_method_id' => 'paymentMethodId',
        'payment_type_id' => 'paymentTypeId',
        'renewal_membership_task_id' => 'renewalMembershipTaskId',
        'initial_deferred_revenue' => 'initialDeferredRevenue',
        'cancellation_balance_invoice_id' => 'cancellationBalanceInvoiceId',
        'cancellation_invoice_id' => 'cancellationInvoiceId'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'business_unit_id' => 'setBusinessUnitId',
        'next_scheduled_bill_date' => 'setNextScheduledBillDate',
        'status' => 'setStatus',
        'memo' => 'setMemo',
        'from' => 'setFrom',
        'to' => 'setTo',
        'sold_by_id' => 'setSoldById',
        'billing_template_id' => 'setBillingTemplateId',
        'location_id' => 'setLocationId',
        'recurring_service_action' => 'setRecurringServiceAction',
        'recurring_location_id' => 'setRecurringLocationId',
        'payment_method_id' => 'setPaymentMethodId',
        'payment_type_id' => 'setPaymentTypeId',
        'renewal_membership_task_id' => 'setRenewalMembershipTaskId',
        'initial_deferred_revenue' => 'setInitialDeferredRevenue',
        'cancellation_balance_invoice_id' => 'setCancellationBalanceInvoiceId',
        'cancellation_invoice_id' => 'setCancellationInvoiceId'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'business_unit_id' => 'getBusinessUnitId',
        'next_scheduled_bill_date' => 'getNextScheduledBillDate',
        'status' => 'getStatus',
        'memo' => 'getMemo',
        'from' => 'getFrom',
        'to' => 'getTo',
        'sold_by_id' => 'getSoldById',
        'billing_template_id' => 'getBillingTemplateId',
        'location_id' => 'getLocationId',
        'recurring_service_action' => 'getRecurringServiceAction',
        'recurring_location_id' => 'getRecurringLocationId',
        'payment_method_id' => 'getPaymentMethodId',
        'payment_type_id' => 'getPaymentTypeId',
        'renewal_membership_task_id' => 'getRenewalMembershipTaskId',
        'initial_deferred_revenue' => 'getInitialDeferredRevenue',
        'cancellation_balance_invoice_id' => 'getCancellationBalanceInvoiceId',
        'cancellation_invoice_id' => 'getCancellationInvoiceId'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }


    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->setIfExists('business_unit_id', $data ?? [], null);
        $this->setIfExists('next_scheduled_bill_date', $data ?? [], null);
        $this->setIfExists('status', $data ?? [], null);
        $this->setIfExists('memo', $data ?? [], null);
        $this->setIfExists('from', $data ?? [], null);
        $this->setIfExists('to', $data ?? [], null);
        $this->setIfExists('sold_by_id', $data ?? [], null);
        $this->setIfExists('billing_template_id', $data ?? [], null);
        $this->setIfExists('location_id', $data ?? [], null);
        $this->setIfExists('recurring_service_action', $data ?? [], null);
        $this->setIfExists('recurring_location_id', $data ?? [], null);
        $this->setIfExists('payment_method_id', $data ?? [], null);
        $this->setIfExists('payment_type_id', $data ?? [], null);
        $this->setIfExists('renewal_membership_task_id', $data ?? [], null);
        $this->setIfExists('initial_deferred_revenue', $data ?? [], null);
        $this->setIfExists('cancellation_balance_invoice_id', $data ?? [], null);
        $this->setIfExists('cancellation_invoice_id', $data ?? [], null);
    }

    /**
    * Sets $this->container[$variableName] to the given data or to the given default Value; if $variableName
    * is nullable and its value is set to null in the $fields array, then mark it as "set to null" in the
    * $this->openAPINullablesSetToNull array
    *
    * @param string $variableName
    * @param array  $fields
    * @param mixed  $defaultValue
    */
    private function setIfExists(string $variableName, array $fields, $defaultValue): void
    {
        if (self::isNullable($variableName) && array_key_exists($variableName, $fields) && is_null($fields[$variableName])) {
            $this->openAPINullablesSetToNull[] = $variableName;
        }

        $this->container[$variableName] = $fields[$variableName] ?? $defaultValue;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets business_unit_id
     *
     * @return int|null
     */
    public function getBusinessUnitId()
    {
        return $this->container['business_unit_id'];
    }

    /**
     * Sets business_unit_id
     *
     * @param int|null $business_unit_id ID of the Business Unit associated to this membership
     *
     * @return self
     */
    public function setBusinessUnitId($business_unit_id)
    {
        if (is_null($business_unit_id)) {
            throw new \InvalidArgumentException('non-nullable business_unit_id cannot be null');
        }
        $this->container['business_unit_id'] = $business_unit_id;

        return $this;
    }

    /**
     * Gets next_scheduled_bill_date
     *
     * @return \DateTime|null
     */
    public function getNextScheduledBillDate()
    {
        return $this->container['next_scheduled_bill_date'];
    }

    /**
     * Sets next_scheduled_bill_date
     *
     * @param \DateTime|null $next_scheduled_bill_date Next date that this membership will be billed on
     *
     * @return self
     */
    public function setNextScheduledBillDate($next_scheduled_bill_date)
    {
        if (is_null($next_scheduled_bill_date)) {
            array_push($this->openAPINullablesSetToNull, 'next_scheduled_bill_date');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('next_scheduled_bill_date', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['next_scheduled_bill_date'] = $next_scheduled_bill_date;

        return $this;
    }

    /**
     * Gets status
     *
     * @return \CompWright\ServiceTitan\Model\MembershipsV2CustomerMembershipUpdateRequestStatus|null
     */
    public function getStatus()
    {
        return $this->container['status'];
    }

    /**
     * Sets status
     *
     * @param \CompWright\ServiceTitan\Model\MembershipsV2CustomerMembershipUpdateRequestStatus|null $status status
     *
     * @return self
     */
    public function setStatus($status)
    {
        if (is_null($status)) {
            throw new \InvalidArgumentException('non-nullable status cannot be null');
        }
        $this->container['status'] = $status;

        return $this;
    }

    /**
     * Gets memo
     *
     * @return string|null
     */
    public function getMemo()
    {
        return $this->container['memo'];
    }

    /**
     * Sets memo
     *
     * @param string|null $memo Memo text field
     *
     * @return self
     */
    public function setMemo($memo)
    {
        if (is_null($memo)) {
            throw new \InvalidArgumentException('non-nullable memo cannot be null');
        }
        $this->container['memo'] = $memo;

        return $this;
    }

    /**
     * Gets from
     *
     * @return \DateTime|null
     */
    public function getFrom()
    {
        return $this->container['from'];
    }

    /**
     * Sets from
     *
     * @param \DateTime|null $from The starting date of this membership
     *
     * @return self
     */
    public function setFrom($from)
    {
        if (is_null($from)) {
            throw new \InvalidArgumentException('non-nullable from cannot be null');
        }
        $this->container['from'] = $from;

        return $this;
    }

    /**
     * Gets to
     *
     * @return \DateTime|null
     */
    public function getTo()
    {
        return $this->container['to'];
    }

    /**
     * Sets to
     *
     * @param \DateTime|null $to The end date of this membership (null if ongoing)
     *
     * @return self
     */
    public function setTo($to)
    {
        if (is_null($to)) {
            array_push($this->openAPINullablesSetToNull, 'to');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('to', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['to'] = $to;

        return $this;
    }

    /**
     * Gets sold_by_id
     *
     * @return int|null
     */
    public function getSoldById()
    {
        return $this->container['sold_by_id'];
    }

    /**
     * Sets sold_by_id
     *
     * @param int|null $sold_by_id ID of the user that was credited for the sale of this membership
     *
     * @return self
     */
    public function setSoldById($sold_by_id)
    {
        if (is_null($sold_by_id)) {
            array_push($this->openAPINullablesSetToNull, 'sold_by_id');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('sold_by_id', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['sold_by_id'] = $sold_by_id;

        return $this;
    }

    /**
     * Gets billing_template_id
     *
     * @return int|null
     */
    public function getBillingTemplateId()
    {
        return $this->container['billing_template_id'];
    }

    /**
     * Sets billing_template_id
     *
     * @param int|null $billing_template_id The ID of the invoice template used to bill this membership. Can either be a \"settings template\" (when invoice template is shared – in this case new invoice template will be created), or be a new invoice template created specifically for this customer membership.
     *
     * @return self
     */
    public function setBillingTemplateId($billing_template_id)
    {
        if (is_null($billing_template_id)) {
            array_push($this->openAPINullablesSetToNull, 'billing_template_id');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('billing_template_id', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['billing_template_id'] = $billing_template_id;

        return $this;
    }

    /**
     * Gets location_id
     *
     * @return int|null
     */
    public function getLocationId()
    {
        return $this->container['location_id'];
    }

    /**
     * Sets location_id
     *
     * @param int|null $location_id Discount location ID of this membership (null if all locations)
     *
     * @return self
     */
    public function setLocationId($location_id)
    {
        if (is_null($location_id)) {
            array_push($this->openAPINullablesSetToNull, 'location_id');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('location_id', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['location_id'] = $location_id;

        return $this;
    }

    /**
     * Gets recurring_service_action
     *
     * @return \CompWright\ServiceTitan\Model\MembershipsV2CustomerMembershipUpdateRequestRecurringServiceAction|null
     */
    public function getRecurringServiceAction()
    {
        return $this->container['recurring_service_action'];
    }

    /**
     * Sets recurring_service_action
     *
     * @param \CompWright\ServiceTitan\Model\MembershipsV2CustomerMembershipUpdateRequestRecurringServiceAction|null $recurring_service_action recurring_service_action
     *
     * @return self
     */
    public function setRecurringServiceAction($recurring_service_action)
    {
        if (is_null($recurring_service_action)) {
            throw new \InvalidArgumentException('non-nullable recurring_service_action cannot be null');
        }
        $this->container['recurring_service_action'] = $recurring_service_action;

        return $this;
    }

    /**
     * Gets recurring_location_id
     *
     * @return int|null
     */
    public function getRecurringLocationId()
    {
        return $this->container['recurring_location_id'];
    }

    /**
     * Sets recurring_location_id
     *
     * @param int|null $recurring_location_id The location at which recurring services are scheduled (null if all locations)
     *
     * @return self
     */
    public function setRecurringLocationId($recurring_location_id)
    {
        if (is_null($recurring_location_id)) {
            array_push($this->openAPINullablesSetToNull, 'recurring_location_id');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('recurring_location_id', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['recurring_location_id'] = $recurring_location_id;

        return $this;
    }

    /**
     * Gets payment_method_id
     *
     * @return int|null
     */
    public function getPaymentMethodId()
    {
        return $this->container['payment_method_id'];
    }

    /**
     * Sets payment_method_id
     *
     * @param int|null $payment_method_id The ID of the payment method (credit card or bank account) that should be used for this membership. This field is mutually exclusive with payment type. Only one or the other can be set at a time.
     *
     * @return self
     */
    public function setPaymentMethodId($payment_method_id)
    {
        if (is_null($payment_method_id)) {
            array_push($this->openAPINullablesSetToNull, 'payment_method_id');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('payment_method_id', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['payment_method_id'] = $payment_method_id;

        return $this;
    }

    /**
     * Gets payment_type_id
     *
     * @return int|null
     */
    public function getPaymentTypeId()
    {
        return $this->container['payment_type_id'];
    }

    /**
     * Sets payment_type_id
     *
     * @param int|null $payment_type_id The payment type (cash, check, etc) that should be used for this membership. This field is mutually exclusive with payment type. Only one or the other can be set at a time. Setting payment type means we will not automatically use a payment method to bill the membership and payment will have to be collected manually.
     *
     * @return self
     */
    public function setPaymentTypeId($payment_type_id)
    {
        if (is_null($payment_type_id)) {
            array_push($this->openAPINullablesSetToNull, 'payment_type_id');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('payment_type_id', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['payment_type_id'] = $payment_type_id;

        return $this;
    }

    /**
     * Gets renewal_membership_task_id
     *
     * @return int|null
     */
    public function getRenewalMembershipTaskId()
    {
        return $this->container['renewal_membership_task_id'];
    }

    /**
     * Sets renewal_membership_task_id
     *
     * @param int|null $renewal_membership_task_id The ID of the service that will be used as the default to renew this membership.
     *
     * @return self
     */
    public function setRenewalMembershipTaskId($renewal_membership_task_id)
    {
        if (is_null($renewal_membership_task_id)) {
            throw new \InvalidArgumentException('non-nullable renewal_membership_task_id cannot be null');
        }
        $this->container['renewal_membership_task_id'] = $renewal_membership_task_id;

        return $this;
    }

    /**
     * Gets initial_deferred_revenue
     *
     * @return float|null
     */
    public function getInitialDeferredRevenue()
    {
        return $this->container['initial_deferred_revenue'];
    }

    /**
     * Sets initial_deferred_revenue
     *
     * @param float|null $initial_deferred_revenue The amount of deferred revenue that this membership should start with that is not accounted for in the sale task.
     *
     * @return self
     */
    public function setInitialDeferredRevenue($initial_deferred_revenue)
    {
        if (is_null($initial_deferred_revenue)) {
            throw new \InvalidArgumentException('non-nullable initial_deferred_revenue cannot be null');
        }
        $this->container['initial_deferred_revenue'] = $initial_deferred_revenue;

        return $this;
    }

    /**
     * Gets cancellation_balance_invoice_id
     *
     * @return int|null
     */
    public function getCancellationBalanceInvoiceId()
    {
        return $this->container['cancellation_balance_invoice_id'];
    }

    /**
     * Sets cancellation_balance_invoice_id
     *
     * @param int|null $cancellation_balance_invoice_id The ID of the invoice created upon membership cancellation in order to zero out the deferred revenue balance.
     *
     * @return self
     */
    public function setCancellationBalanceInvoiceId($cancellation_balance_invoice_id)
    {
        if (is_null($cancellation_balance_invoice_id)) {
            array_push($this->openAPINullablesSetToNull, 'cancellation_balance_invoice_id');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('cancellation_balance_invoice_id', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['cancellation_balance_invoice_id'] = $cancellation_balance_invoice_id;

        return $this;
    }

    /**
     * Gets cancellation_invoice_id
     *
     * @return int|null
     */
    public function getCancellationInvoiceId()
    {
        return $this->container['cancellation_invoice_id'];
    }

    /**
     * Sets cancellation_invoice_id
     *
     * @param int|null $cancellation_invoice_id The ID of the invoice optionally created upon membership cancellation in order to charge (or refund) the customer if deferred revenue balance is not 0.
     *
     * @return self
     */
    public function setCancellationInvoiceId($cancellation_invoice_id)
    {
        if (is_null($cancellation_invoice_id)) {
            array_push($this->openAPINullablesSetToNull, 'cancellation_invoice_id');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('cancellation_invoice_id', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['cancellation_invoice_id'] = $cancellation_invoice_id;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


