<?php

declare(strict_types=1);

/*
 * This file has been auto generated by Jane,
 *
 * Do no edit it directly.
 */

namespace CompWright\ServiceTitan;

class MembershipsClient extends \CompWright\ServiceTitan\Runtime\Client\Client
{
    /**
     * Gets a list of customer memberships.
     *
     * @param int   $tenant          Tenant ID
     * @param array $queryParameters {
     *
     *     @var string $ids Perform lookup by multiple IDs (maximum 50)
     *     @var string $customerIds Filters by customer IDs
     *     @var string $active What kind of items should be returned (only active items will be returned by default)\
     *     @var string $status Filters by membership status\
     *     @var int $duration Format - int32. Filters by membership duration (in months); use null for ongoing memberships
     *     @var string $billingFrequency Filters by membership billing frequency\
     *     @var string $createdBefore Format - date-time (as date-time in RFC3339). Return items created before certain date/time (in UTC)
     *     @var string $createdOnOrAfter Format - date-time (as date-time in RFC3339). Return items created on or after certain date/time (in UTC)
     *     @var string $modifiedBefore Format - date-time (as date-time in RFC3339). Return items modified before certain date/time (in UTC)
     *     @var string $modifiedOnOrAfter Format - date-time (as date-time in RFC3339). Return items modified on or after certain date/time (in UTC)
     *     @var int $page Format - int32. The logical number of page to return, starting from 1
     *     @var int $pageSize Format - int32. How many records to return (50 by default)
     *     @var bool $includeTotal Whether total count should be returned
     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \CompWright\ServiceTitan\Exception\CustomerMembershipsGetListBadRequestException
     *
     * @return \CompWright\ServiceTitan\Model\PaginatedResponseOfMembershipsV2CustomerMembershipResponse|\Psr\Http\Message\ResponseInterface|null
     */
    public function customerMembershipsGetList(int $tenant, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \CompWright\ServiceTitan\Endpoint\CustomerMembershipsGetList($tenant, $queryParameters), $fetch);
    }

    /**
     * Gets customer membership specified by ID.
     *
     * @param int    $id     Format - int64. Customer membership ID
     * @param int    $tenant Tenant ID
     * @param string $fetch  Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \CompWright\ServiceTitan\Exception\CustomerMembershipsGetBadRequestException
     * @throws \CompWright\ServiceTitan\Exception\CustomerMembershipsGetNotFoundException
     *
     * @return \CompWright\ServiceTitan\Model\MembershipsV2CustomerMembershipResponse|\Psr\Http\Message\ResponseInterface|null
     */
    public function customerMembershipsGet(int $id, int $tenant, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \CompWright\ServiceTitan\Endpoint\CustomerMembershipsGet($id, $tenant), $fetch);
    }

    /**
     * Updates specified customer membership in "patch" mode.
     *
     * @param int                                                                              $id          Format - int64. Customer membership ID
     * @param int                                                                              $tenant      Tenant ID
     * @param \CompWright\ServiceTitan\Model\MembershipsV2CustomerMembershipUpdateRequest|null $requestBody
     * @param string                                                                           $fetch       Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \CompWright\ServiceTitan\Exception\CustomerMembershipsUpdateBadRequestException
     * @throws \CompWright\ServiceTitan\Exception\CustomerMembershipsUpdateNotFoundException
     *
     * @return \CompWright\ServiceTitan\Model\ModificationResponse|\Psr\Http\Message\ResponseInterface|null
     */
    public function customerMembershipsUpdate(int $id, int $tenant, ?Model\MembershipsV2CustomerMembershipUpdateRequest $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \CompWright\ServiceTitan\Endpoint\CustomerMembershipsUpdate($id, $tenant, $requestBody), $fetch);
    }

    /**
     * Creates membership sale invoice.
     *
     * @param int                                                                                 $tenant      Tenant ID
     * @param \CompWright\ServiceTitan\Model\MembershipsV2MembershipSaleInvoiceCreateRequest|null $requestBody
     * @param string                                                                              $fetch       Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \CompWright\ServiceTitan\Exception\CustomerMembershipsCreateBadRequestException
     *
     * @return \CompWright\ServiceTitan\Model\MembershipsV2MembershipSaleInvoiceCreateResponse|\Psr\Http\Message\ResponseInterface|null
     */
    public function customerMembershipsCreate(int $tenant, ?Model\MembershipsV2MembershipSaleInvoiceCreateRequest $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \CompWright\ServiceTitan\Endpoint\CustomerMembershipsCreate($tenant, $requestBody), $fetch);
    }

    /**
     * Please note this endpoint does not allow to enumerate all invoice templates.
     *
     * @param int   $tenant          Tenant ID
     * @param array $queryParameters {
     *
     *     @var string $ids Perform lookup by multiple IDs (maximum 50)
     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \CompWright\ServiceTitan\Exception\InvoiceTemplatesGetListBadRequestException
     *
     * @return \CompWright\ServiceTitan\Model\PaginatedResponseOfMembershipsV2InvoiceTemplateResponse|\Psr\Http\Message\ResponseInterface|null
     */
    public function invoiceTemplatesGetList(int $tenant, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \CompWright\ServiceTitan\Endpoint\InvoiceTemplatesGetList($tenant, $queryParameters), $fetch);
    }

    /**
     * Creates new invoice template.
     *
     * @param int                                                                           $tenant      Tenant ID
     * @param \CompWright\ServiceTitan\Model\MembershipsV2InvoiceTemplateCreateRequest|null $requestBody
     * @param string                                                                        $fetch       Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \CompWright\ServiceTitan\Exception\InvoiceTemplatesCreateBadRequestException
     *
     * @return \CompWright\ServiceTitan\Model\ModificationResponse|\Psr\Http\Message\ResponseInterface|null
     */
    public function invoiceTemplatesCreate(int $tenant, ?Model\MembershipsV2InvoiceTemplateCreateRequest $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \CompWright\ServiceTitan\Endpoint\InvoiceTemplatesCreate($tenant, $requestBody), $fetch);
    }

    /**
     * Gets invoice template specified by ID.
     *
     * @param int    $id     Format - int64. Invoice template ID
     * @param int    $tenant Tenant ID
     * @param string $fetch  Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \CompWright\ServiceTitan\Exception\InvoiceTemplatesGetBadRequestException
     * @throws \CompWright\ServiceTitan\Exception\InvoiceTemplatesGetNotFoundException
     *
     * @return \CompWright\ServiceTitan\Model\MembershipsV2InvoiceTemplateResponse|\Psr\Http\Message\ResponseInterface|null
     */
    public function invoiceTemplatesGet(int $id, int $tenant, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \CompWright\ServiceTitan\Endpoint\InvoiceTemplatesGet($id, $tenant), $fetch);
    }

    /**
     * Updates specified invoice template in "patch" mode.
     *
     * @param int                                                                           $id          Format - int64. Invoice template ID
     * @param int                                                                           $tenant      Tenant ID
     * @param \CompWright\ServiceTitan\Model\MembershipsV2InvoiceTemplateUpdateRequest|null $requestBody
     * @param string                                                                        $fetch       Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \CompWright\ServiceTitan\Exception\InvoiceTemplatesUpdateBadRequestException
     * @throws \CompWright\ServiceTitan\Exception\InvoiceTemplatesUpdateNotFoundException
     *
     * @return \CompWright\ServiceTitan\Model\ModificationResponse|\Psr\Http\Message\ResponseInterface|null
     */
    public function invoiceTemplatesUpdate(int $id, int $tenant, ?Model\MembershipsV2InvoiceTemplateUpdateRequest $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \CompWright\ServiceTitan\Endpoint\InvoiceTemplatesUpdate($id, $tenant, $requestBody), $fetch);
    }

    /**
     * Gets a list of recurring service events.
     *
     * @param int   $tenant          Tenant ID
     * @param array $queryParameters {
     *
     *     @var string $ids Perform lookup by multiple IDs (maximum 50)
     *     @var int $locationId Format - int64. Location ID
     *     @var int $jobId Format - int64. Job ID
     *     @var string $status Follow up status \
     *     @var string $createdBefore Format - date-time (as date-time in RFC3339). Return items created before certain date/time (in UTC)
     *     @var string $createdOnOrAfter Format - date-time (as date-time in RFC3339). Return items created on or after certain date/time (in UTC)
     *     @var int $page Format - int32. The logical number of page to return, starting from 1
     *     @var int $pageSize Format - int32. How many records to return (50 by default)
     *     @var bool $includeTotal Whether total count should be returned
     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \CompWright\ServiceTitan\Exception\LocationRecurringServiceEventsGetListBadRequestException
     *
     * @return \CompWright\ServiceTitan\Model\PaginatedResponseOfMembershipsV2LocationRecurringServiceEventResponse|\Psr\Http\Message\ResponseInterface|null
     */
    public function locationRecurringServiceEventsGetList(int $tenant, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \CompWright\ServiceTitan\Endpoint\LocationRecurringServiceEventsGetList($tenant, $queryParameters), $fetch);
    }

    /**
     * Marking an event as complete links the job with provided JobID to the given Location Recurring Service Event.
     *
     * @param int                                                                                    $id          Format - int64. Recurring service event ID
     * @param int                                                                                    $tenant      Tenant ID
     * @param \CompWright\ServiceTitan\Model\MembershipsV2MarkEventCompletedStatusUpdateRequest|null $requestBody
     * @param string                                                                                 $fetch       Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \CompWright\ServiceTitan\Exception\LocationRecurringServiceEventsMarkCompleteBadRequestException
     * @throws \CompWright\ServiceTitan\Exception\LocationRecurringServiceEventsMarkCompleteNotFoundException
     *
     * @return \CompWright\ServiceTitan\Model\ModificationResponse|\Psr\Http\Message\ResponseInterface|null
     */
    public function locationRecurringServiceEventsMarkComplete(int $id, int $tenant, ?Model\MembershipsV2MarkEventCompletedStatusUpdateRequest $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \CompWright\ServiceTitan\Endpoint\LocationRecurringServiceEventsMarkComplete($id, $tenant, $requestBody), $fetch);
    }

    /**
     * Marking an event as incomplete unlinks the job with provided JobID to the given Location Recurring Service.
     *
     * @param int                                                                                    $id          Format - int64. Recurring service event ID
     * @param int                                                                                    $tenant      Tenant ID
     * @param \CompWright\ServiceTitan\Model\MembershipsV2MarkEventCompletedStatusUpdateRequest|null $requestBody
     * @param string                                                                                 $fetch       Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \CompWright\ServiceTitan\Exception\LocationRecurringServiceEventsMarkIncompleteBadRequestException
     * @throws \CompWright\ServiceTitan\Exception\LocationRecurringServiceEventsMarkIncompleteNotFoundException
     *
     * @return \CompWright\ServiceTitan\Model\ModificationResponse|\Psr\Http\Message\ResponseInterface|null
     */
    public function locationRecurringServiceEventsMarkIncomplete(int $id, int $tenant, ?Model\MembershipsV2MarkEventCompletedStatusUpdateRequest $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \CompWright\ServiceTitan\Endpoint\LocationRecurringServiceEventsMarkIncomplete($id, $tenant, $requestBody), $fetch);
    }

    /**
     * Gets a list of recurring services.
     *
     * @param int   $tenant          Tenant ID
     * @param array $queryParameters {
     *
     *     @var string $ids Perform lookup by multiple IDs (maximum 50)
     *     @var string $membershipIds Filters by customer membership IDs
     *     @var string $locationIds Filters by location IDs
     *     @var string $active What kind of items should be returned (only active items will be returned by default)\
     *     @var string $createdBefore Format - date-time (as date-time in RFC3339). Return items created before certain date/time (in UTC)
     *     @var string $createdOnOrAfter Format - date-time (as date-time in RFC3339). Return items created on or after certain date/time (in UTC)
     *     @var string $modifiedBefore Format - date-time (as date-time in RFC3339). Return items modified before certain date/time (in UTC)
     *     @var string $modifiedOnOrAfter Format - date-time (as date-time in RFC3339). Return items modified on or after certain date/time (in UTC)
     *     @var int $page Format - int32. The logical number of page to return, starting from 1
     *     @var int $pageSize Format - int32. How many records to return (50 by default)
     *     @var bool $includeTotal Whether total count should be returned
     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \CompWright\ServiceTitan\Exception\LocationRecurringServicesGetListBadRequestException
     *
     * @return \CompWright\ServiceTitan\Model\PaginatedResponseOfMembershipsV2LocationRecurringServiceResponse|\Psr\Http\Message\ResponseInterface|null
     */
    public function locationRecurringServicesGetList(int $tenant, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \CompWright\ServiceTitan\Endpoint\LocationRecurringServicesGetList($tenant, $queryParameters), $fetch);
    }

    /**
     * Gets recurring service specified by ID.
     *
     * @param int    $id     Format - int64. Recurring service ID
     * @param int    $tenant Tenant ID
     * @param string $fetch  Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \CompWright\ServiceTitan\Exception\LocationRecurringServicesGetBadRequestException
     * @throws \CompWright\ServiceTitan\Exception\LocationRecurringServicesGetNotFoundException
     *
     * @return \CompWright\ServiceTitan\Model\MembershipsV2LocationRecurringServiceResponse|\Psr\Http\Message\ResponseInterface|null
     */
    public function locationRecurringServicesGet(int $id, int $tenant, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \CompWright\ServiceTitan\Endpoint\LocationRecurringServicesGet($id, $tenant), $fetch);
    }

    /**
     * Updates specified recurring service in "patch" mode.
     *
     * @param int                                                                                    $id          Format - int64. Recurring service ID
     * @param int                                                                                    $tenant      Tenant ID
     * @param \CompWright\ServiceTitan\Model\MembershipsV2LocationRecurringServiceUpdateRequest|null $requestBody
     * @param string                                                                                 $fetch       Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \CompWright\ServiceTitan\Exception\LocationRecurringServicesUpdateBadRequestException
     * @throws \CompWright\ServiceTitan\Exception\LocationRecurringServicesUpdateNotFoundException
     *
     * @return \CompWright\ServiceTitan\Model\ModificationResponse|\Psr\Http\Message\ResponseInterface|null
     */
    public function locationRecurringServicesUpdate(int $id, int $tenant, ?Model\MembershipsV2LocationRecurringServiceUpdateRequest $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \CompWright\ServiceTitan\Endpoint\LocationRecurringServicesUpdate($id, $tenant, $requestBody), $fetch);
    }

    /**
     * Gets a list of membership types.
     *
     * @param int   $tenant          Tenant ID
     * @param array $queryParameters {
     *
     *     @var string $ids Perform lookup by multiple IDs (maximum 50)
     *     @var string $active What kind of items should be returned (only active items will be returned by default)\
     *     @var int $duration Format - int32. Filters by membership duration (in months); use null for ongoing memberships
     *     @var string $billingFrequency Filters by membership billing frequency\
     *     @var string $createdBefore Format - date-time (as date-time in RFC3339). Return items created before certain date/time (in UTC)
     *     @var string $createdOnOrAfter Format - date-time (as date-time in RFC3339). Return items created on or after certain date/time (in UTC)
     *     @var string $modifiedBefore Format - date-time (as date-time in RFC3339). Return items modified before certain date/time (in UTC)
     *     @var string $modifiedOnOrAfter Format - date-time (as date-time in RFC3339). Return items modified on or after certain date/time (in UTC)
     *     @var int $page Format - int32. The logical number of page to return, starting from 1
     *     @var int $pageSize Format - int32. How many records to return (50 by default)
     *     @var bool $includeTotal Whether total count should be returned
     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \CompWright\ServiceTitan\Exception\MembershipTypesGetListBadRequestException
     *
     * @return \CompWright\ServiceTitan\Model\PaginatedResponseOfMembershipsV2MembershipTypeResponse|\Psr\Http\Message\ResponseInterface|null
     */
    public function membershipTypesGetList(int $tenant, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \CompWright\ServiceTitan\Endpoint\MembershipTypesGetList($tenant, $queryParameters), $fetch);
    }

    /**
     * Gets membership type specified by ID.
     *
     * @param int    $id     Format - int64. Membership type ID
     * @param int    $tenant Tenant ID
     * @param string $fetch  Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \CompWright\ServiceTitan\Exception\MembershipTypesGetBadRequestException
     * @throws \CompWright\ServiceTitan\Exception\MembershipTypesGetNotFoundException
     *
     * @return \CompWright\ServiceTitan\Model\MembershipsV2MembershipTypeResponse|\Psr\Http\Message\ResponseInterface|null
     */
    public function membershipTypesGet(int $id, int $tenant, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \CompWright\ServiceTitan\Endpoint\MembershipTypesGet($id, $tenant), $fetch);
    }

    /**
     * Gets recurring services for the given membership type.
     *
     * @param int    $id     Format - int64. Membership type ID
     * @param int    $tenant Tenant ID
     * @param string $fetch  Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \CompWright\ServiceTitan\Exception\MembershipTypesGetRecurringServiceItemsBadRequestException
     * @throws \CompWright\ServiceTitan\Exception\MembershipTypesGetRecurringServiceItemsNotFoundException
     *
     * @return \CompWright\ServiceTitan\Model\MembershipsV2MembershipTypeRecurringServiceItemResponse[]|\Psr\Http\Message\ResponseInterface|null
     */
    public function membershipTypesGetRecurringServiceItems(int $id, int $tenant, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \CompWright\ServiceTitan\Endpoint\MembershipTypesGetRecurringServiceItems($id, $tenant), $fetch);
    }

    /**
     * Gets discounts for the given membership type.
     *
     * @param int    $id     Format - int64. Membership type ID
     * @param int    $tenant Tenant ID
     * @param string $fetch  Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \CompWright\ServiceTitan\Exception\MembershipTypesGetDiscountsListBadRequestException
     * @throws \CompWright\ServiceTitan\Exception\MembershipTypesGetDiscountsListNotFoundException
     *
     * @return \CompWright\ServiceTitan\Model\MembershipsV2MembershipTypeDiscountItemResponse[]|\Psr\Http\Message\ResponseInterface|null
     */
    public function membershipTypesGetDiscountsList(int $id, int $tenant, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \CompWright\ServiceTitan\Endpoint\MembershipTypesGetDiscountsList($id, $tenant), $fetch);
    }

    /**
     * Gets duration/billing options for the given membership type.
     *
     * @param int   $id              Format - int64. Membership type ID
     * @param int   $tenant          Tenant ID
     * @param array $queryParameters {
     *
     *     @var string $active What kind of items should be returned (only active items will be returned by default)\
    Values: [True, Any, False]
     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \CompWright\ServiceTitan\Exception\MembershipTypesGetDurationBillingListBadRequestException
     * @throws \CompWright\ServiceTitan\Exception\MembershipTypesGetDurationBillingListNotFoundException
     *
     * @return \CompWright\ServiceTitan\Model\MembershipsV2MembershipTypeDurationBillingItemResponse[]|\Psr\Http\Message\ResponseInterface|null
     */
    public function membershipTypesGetDurationBillingList(int $id, int $tenant, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \CompWright\ServiceTitan\Endpoint\MembershipTypesGetDurationBillingList($id, $tenant, $queryParameters), $fetch);
    }

    /**
     * Gets a list of recurring service types.
     *
     * @param int   $tenant          Tenant ID
     * @param array $queryParameters {
     *
     *     @var string $ids Perform lookup by multiple IDs (maximum 50)
     *     @var int $membershipTypeId Format - int64. Filters by membership type ID
     *     @var string $active What kind of items should be returned (only active items will be returned by default)\
     *     @var string $recurrenceType Filters by recurrence type\
     *     @var string $durationType Filters by duration type\
     *     @var int $page Format - int32. The logical number of page to return, starting from 1
     *     @var int $pageSize Format - int32. How many records to return (50 by default)
     *     @var bool $includeTotal Whether total count should be returned
     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \CompWright\ServiceTitan\Exception\RecurringServiceTypesGetListBadRequestException
     *
     * @return \CompWright\ServiceTitan\Model\PaginatedResponseOfMembershipsV2RecurringServiceTypeResponse|\Psr\Http\Message\ResponseInterface|null
     */
    public function recurringServiceTypesGetList(int $tenant, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \CompWright\ServiceTitan\Endpoint\RecurringServiceTypesGetList($tenant, $queryParameters), $fetch);
    }

    /**
     * Gets recurring service type specified by ID.
     *
     * @param int    $id     Format - int64. Recurring service type ID
     * @param int    $tenant Tenant ID
     * @param string $fetch  Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \CompWright\ServiceTitan\Exception\RecurringServiceTypesGetBadRequestException
     * @throws \CompWright\ServiceTitan\Exception\RecurringServiceTypesGetNotFoundException
     *
     * @return \CompWright\ServiceTitan\Model\MembershipsV2RecurringServiceTypeResponse|\Psr\Http\Message\ResponseInterface|null
     */
    public function recurringServiceTypesGet(int $id, int $tenant, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \CompWright\ServiceTitan\Endpoint\RecurringServiceTypesGet($id, $tenant), $fetch);
    }

    public static function create($httpClient = null, array $additionalPlugins = [], array $additionalNormalizers = [])
    {
        if (null === $httpClient) {
            $httpClient = \Http\Discovery\Psr18ClientDiscovery::find();
            $plugins = [];
            $uri = \Http\Discovery\Psr17FactoryDiscovery::findUrlFactory()->createUri('https://api.servicetitan.io');
            $plugins[] = new \Http\Client\Common\Plugin\AddHostPlugin($uri);
            if (count($additionalPlugins) > 0) {
                $plugins = array_merge($plugins, $additionalPlugins);
            }
            $httpClient = new \Http\Client\Common\PluginClient($httpClient, $plugins);
        }
        $requestFactory = \Http\Discovery\Psr17FactoryDiscovery::findRequestFactory();
        $streamFactory = \Http\Discovery\Psr17FactoryDiscovery::findStreamFactory();
        $normalizers = [new \Symfony\Component\Serializer\Normalizer\ArrayDenormalizer(), new \CompWright\ServiceTitan\Normalizer\JaneObjectNormalizer()];
        if (count($additionalNormalizers) > 0) {
            $normalizers = array_merge($normalizers, $additionalNormalizers);
        }
        $serializer = new \Symfony\Component\Serializer\Serializer($normalizers, [new \Symfony\Component\Serializer\Encoder\JsonEncoder(new \Symfony\Component\Serializer\Encoder\JsonEncode(), new \Symfony\Component\Serializer\Encoder\JsonDecode(['json_decode_associative' => true]))]);

        return new static($httpClient, $requestFactory, $serializer, $streamFactory);
    }
}
