<?php

declare(strict_types=1);

/*
 * This file has been auto generated by Jane,
 *
 * Do no edit it directly.
 */

namespace CompWright\ServiceTitan\Model;

class MembershipsV2CustomerMembershipUpdateRequest
{
    /**
     * @var array
     */
    protected $initialized = [];

    public function isInitialized($property): bool
    {
        return array_key_exists($property, $this->initialized);
    }
    /**
     * ID of the Business Unit associated to this membership.
     *
     * @var int
     */
    protected $businessUnitId;
    /**
     * Next date that this membership will be billed on.
     *
     * @var \DateTime|null
     */
    protected $nextScheduledBillDate;
    /**
     * Status of the membership.
     */
    protected $status;
    /**
     * Memo text field.
     *
     * @var string
     */
    protected $memo;
    /**
     * The starting date of this membership.
     *
     * @var \DateTime
     */
    protected $from;
    /**
     * The end date of this membership (null if ongoing).
     *
     * @var \DateTime|null
     */
    protected $to;
    /**
     * ID of the user that was credited for the sale of this membership.
     *
     * @var int|null
     */
    protected $soldById;
    /**
     * The ID of the invoice template used to bill this membership.
     * Can either be a "settings template" (when invoice template is shared – in this case new invoice template will be created),
     * or be a new invoice template created specifically for this customer membership.
     *
     * @var int|null
     */
    protected $billingTemplateId;
    /**
     * Discount location ID of this membership (null if all locations).
     *
     * @var int|null
     */
    protected $locationId;
    /**
     * Required if RecurringLocationId is set.
     * Determines how many of the customer's locations that recurring services should be added to: all, single, or none (which deletes existing recurring services).
     */
    protected $recurringServiceAction;
    /**
     * The location at which recurring services are scheduled (null if all locations).
     *
     * @var int|null
     */
    protected $recurringLocationId;
    /**
     * The ID of the payment method (credit card or bank account) that should be used for this membership. This
     * field is mutually exclusive with payment type. Only one or the other can be set at a time.
     *
     * @var int|null
     */
    protected $paymentMethodId;
    /**
     * The payment type (cash, check, etc) that should be used for this membership. This field is mutually
     * exclusive with payment type. Only one or the other can be set at a time. Setting payment type means we will
     * not automatically use a payment method to bill the membership and payment will have to be collected manually.
     *
     * @var int|null
     */
    protected $paymentTypeId;
    /**
     * The ID of the service that will be used as the default to renew this membership.
     *
     * @var int
     */
    protected $renewalMembershipTaskId;
    /**
     * The amount of deferred revenue that this membership should start with that is not accounted for
     * in the sale task.
     *
     * @var float
     */
    protected $initialDeferredRevenue;
    /**
     * The ID of the invoice created upon membership cancellation in order to zero out the deferred revenue balance.
     *
     * @var int|null
     */
    protected $cancellationBalanceInvoiceId;
    /**
     * The ID of the invoice optionally created upon membership cancellation in order to charge (or refund) the
     * customer if deferred revenue balance is not 0.
     *
     * @var int|null
     */
    protected $cancellationInvoiceId;

    /**
     * ID of the Business Unit associated to this membership.
     */
    public function getBusinessUnitId(): int
    {
        return $this->businessUnitId;
    }

    /**
     * ID of the Business Unit associated to this membership.
     */
    public function setBusinessUnitId(int $businessUnitId): self
    {
        $this->initialized['businessUnitId'] = true;
        $this->businessUnitId = $businessUnitId;

        return $this;
    }

    /**
     * Next date that this membership will be billed on.
     */
    public function getNextScheduledBillDate(): ?\DateTime
    {
        return $this->nextScheduledBillDate;
    }

    /**
     * Next date that this membership will be billed on.
     */
    public function setNextScheduledBillDate(?\DateTime $nextScheduledBillDate): self
    {
        $this->initialized['nextScheduledBillDate'] = true;
        $this->nextScheduledBillDate = $nextScheduledBillDate;

        return $this;
    }

    /**
     * Status of the membership.
     */
    public function getStatus()
    {
        return $this->status;
    }

    /**
     * Status of the membership.
     */
    public function setStatus($status): self
    {
        $this->initialized['status'] = true;
        $this->status = $status;

        return $this;
    }

    /**
     * Memo text field.
     */
    public function getMemo(): string
    {
        return $this->memo;
    }

    /**
     * Memo text field.
     */
    public function setMemo(string $memo): self
    {
        $this->initialized['memo'] = true;
        $this->memo = $memo;

        return $this;
    }

    /**
     * The starting date of this membership.
     */
    public function getFrom(): \DateTime
    {
        return $this->from;
    }

    /**
     * The starting date of this membership.
     */
    public function setFrom(\DateTime $from): self
    {
        $this->initialized['from'] = true;
        $this->from = $from;

        return $this;
    }

    /**
     * The end date of this membership (null if ongoing).
     */
    public function getTo(): ?\DateTime
    {
        return $this->to;
    }

    /**
     * The end date of this membership (null if ongoing).
     */
    public function setTo(?\DateTime $to): self
    {
        $this->initialized['to'] = true;
        $this->to = $to;

        return $this;
    }

    /**
     * ID of the user that was credited for the sale of this membership.
     */
    public function getSoldById(): ?int
    {
        return $this->soldById;
    }

    /**
     * ID of the user that was credited for the sale of this membership.
     */
    public function setSoldById(?int $soldById): self
    {
        $this->initialized['soldById'] = true;
        $this->soldById = $soldById;

        return $this;
    }

    /**
     * The ID of the invoice template used to bill this membership.
     * Can either be a "settings template" (when invoice template is shared – in this case new invoice template will be created),
     * or be a new invoice template created specifically for this customer membership.
     */
    public function getBillingTemplateId(): ?int
    {
        return $this->billingTemplateId;
    }

    /**
     * The ID of the invoice template used to bill this membership.
     * Can either be a "settings template" (when invoice template is shared – in this case new invoice template will be created),
     * or be a new invoice template created specifically for this customer membership.
     */
    public function setBillingTemplateId(?int $billingTemplateId): self
    {
        $this->initialized['billingTemplateId'] = true;
        $this->billingTemplateId = $billingTemplateId;

        return $this;
    }

    /**
     * Discount location ID of this membership (null if all locations).
     */
    public function getLocationId(): ?int
    {
        return $this->locationId;
    }

    /**
     * Discount location ID of this membership (null if all locations).
     */
    public function setLocationId(?int $locationId): self
    {
        $this->initialized['locationId'] = true;
        $this->locationId = $locationId;

        return $this;
    }

    /**
     * Required if RecurringLocationId is set.
     * Determines how many of the customer's locations that recurring services should be added to: all, single, or none (which deletes existing recurring services).
     */
    public function getRecurringServiceAction()
    {
        return $this->recurringServiceAction;
    }

    /**
     * Required if RecurringLocationId is set.
     * Determines how many of the customer's locations that recurring services should be added to: all, single, or none (which deletes existing recurring services).
     */
    public function setRecurringServiceAction($recurringServiceAction): self
    {
        $this->initialized['recurringServiceAction'] = true;
        $this->recurringServiceAction = $recurringServiceAction;

        return $this;
    }

    /**
     * The location at which recurring services are scheduled (null if all locations).
     */
    public function getRecurringLocationId(): ?int
    {
        return $this->recurringLocationId;
    }

    /**
     * The location at which recurring services are scheduled (null if all locations).
     */
    public function setRecurringLocationId(?int $recurringLocationId): self
    {
        $this->initialized['recurringLocationId'] = true;
        $this->recurringLocationId = $recurringLocationId;

        return $this;
    }

    /**
     * The ID of the payment method (credit card or bank account) that should be used for this membership. This
     * field is mutually exclusive with payment type. Only one or the other can be set at a time.
     */
    public function getPaymentMethodId(): ?int
    {
        return $this->paymentMethodId;
    }

    /**
     * The ID of the payment method (credit card or bank account) that should be used for this membership. This
     * field is mutually exclusive with payment type. Only one or the other can be set at a time.
     */
    public function setPaymentMethodId(?int $paymentMethodId): self
    {
        $this->initialized['paymentMethodId'] = true;
        $this->paymentMethodId = $paymentMethodId;

        return $this;
    }

    /**
     * The payment type (cash, check, etc) that should be used for this membership. This field is mutually
     * exclusive with payment type. Only one or the other can be set at a time. Setting payment type means we will
     * not automatically use a payment method to bill the membership and payment will have to be collected manually.
     */
    public function getPaymentTypeId(): ?int
    {
        return $this->paymentTypeId;
    }

    /**
     * The payment type (cash, check, etc) that should be used for this membership. This field is mutually
     * exclusive with payment type. Only one or the other can be set at a time. Setting payment type means we will
     * not automatically use a payment method to bill the membership and payment will have to be collected manually.
     */
    public function setPaymentTypeId(?int $paymentTypeId): self
    {
        $this->initialized['paymentTypeId'] = true;
        $this->paymentTypeId = $paymentTypeId;

        return $this;
    }

    /**
     * The ID of the service that will be used as the default to renew this membership.
     */
    public function getRenewalMembershipTaskId(): int
    {
        return $this->renewalMembershipTaskId;
    }

    /**
     * The ID of the service that will be used as the default to renew this membership.
     */
    public function setRenewalMembershipTaskId(int $renewalMembershipTaskId): self
    {
        $this->initialized['renewalMembershipTaskId'] = true;
        $this->renewalMembershipTaskId = $renewalMembershipTaskId;

        return $this;
    }

    /**
     * The amount of deferred revenue that this membership should start with that is not accounted for
     * in the sale task.
     */
    public function getInitialDeferredRevenue(): float
    {
        return $this->initialDeferredRevenue;
    }

    /**
     * The amount of deferred revenue that this membership should start with that is not accounted for
     * in the sale task.
     */
    public function setInitialDeferredRevenue(float $initialDeferredRevenue): self
    {
        $this->initialized['initialDeferredRevenue'] = true;
        $this->initialDeferredRevenue = $initialDeferredRevenue;

        return $this;
    }

    /**
     * The ID of the invoice created upon membership cancellation in order to zero out the deferred revenue balance.
     */
    public function getCancellationBalanceInvoiceId(): ?int
    {
        return $this->cancellationBalanceInvoiceId;
    }

    /**
     * The ID of the invoice created upon membership cancellation in order to zero out the deferred revenue balance.
     */
    public function setCancellationBalanceInvoiceId(?int $cancellationBalanceInvoiceId): self
    {
        $this->initialized['cancellationBalanceInvoiceId'] = true;
        $this->cancellationBalanceInvoiceId = $cancellationBalanceInvoiceId;

        return $this;
    }

    /**
     * The ID of the invoice optionally created upon membership cancellation in order to charge (or refund) the
     * customer if deferred revenue balance is not 0.
     */
    public function getCancellationInvoiceId(): ?int
    {
        return $this->cancellationInvoiceId;
    }

    /**
     * The ID of the invoice optionally created upon membership cancellation in order to charge (or refund) the
     * customer if deferred revenue balance is not 0.
     */
    public function setCancellationInvoiceId(?int $cancellationInvoiceId): self
    {
        $this->initialized['cancellationInvoiceId'] = true;
        $this->cancellationInvoiceId = $cancellationInvoiceId;

        return $this;
    }
}
